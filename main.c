#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <getopt.h>

#include "reg_api.h"
#include "memdev2.h"

#define VERSION "0.1"
static char *project = "samconf";

static void usage(const char *name)
{
	fprintf(stderr, "Usage:\t%s { address } [ type [ data ] ]\n"
		"      \t%s [ option ] ...\n"
		"\taddress : memory address to act upon\n"
		"\ttype    : access operation type : [b]yte, [h]alfword, [w]ord\n"
		"\tdata    : data to be written\n"
		"\toption  : -c,                   list all supported SAM chips\n"
		"\t          -m,                   list all modules of current chip\n"
		"\t          -r module             list all registers of module\n"
		"\t          -D module [ > file ]  safe dump registers' data of module\n"
		"\t          -F                    force dump all registers' data\n"
		"\t          -C file               compare registers' data which generated by -D option\n"
		"\t          -s name               list with similar name\n"
		"\t          -a,                   list with more information\n"
		"\t\"cp samconf NAME_IN_CHIP_LIST\" to force selection chip\n",
		name, name);
}

int cmdline(void)
{
	uchar c;

	fprintf(stdout, "samconf # ");

	while(1) {
		c = getchar();
		if (c == '\n') {
			fprintf(stdout, "samconf # ");
		}
	}

	return 0;
}

char *strip_path(char *file_path)
{
	char *file = strrchr(file_path, '/');

	return file==NULL?file_path:file+1;
}

int main(int argc, char **argv) {
	int ret;
	int i;
	int access = 0;
	ulong address, data = 0;
	char *ip_name, *reg_name;
	int id_chip = -1, id_similar = -1;
	int exit_error = 0;

	static struct option options[] = {
		{"chip"    ,  no_argument      , NULL, 'c'},
		{"module"  ,  no_argument      , NULL, 'm'},
		{"register",  required_argument, NULL, 'r'},
		{"dump"    ,  required_argument, NULL, 'D'},
		{"force"   ,  no_argument      , NULL, 'F'},
		{"compare" ,  required_argument, NULL, 'C'},
		{"similar" ,  required_argument, NULL, 's'},
		{"more"    ,  no_argument      , NULL, 'a'},
		{"help"    ,  no_argument      , NULL, 'h'},
		{"version" ,  no_argument      , NULL, 'v'},
		{0, 0, 0, 0}
	};

	char *opt_string   = "cmr:D:FC:s:ahv";
	char *similar_name = NULL;
	//char *file_path    = NULL;
	int force_dump     = 0;
	info_id info       = INFO_LIST_BASIC;

	if (strstr(strip_path(argv[0]), project) == NULL) {
		id_chip = exist_chip(&sam_chips, strip_path(argv[0]));
		if (id_chip < 0) {
			printf("WARRING: force selection chip Error, chip %s does not exist.\n", \
				strip_path(argv[0]));
		} else {
			if (argc <=1)
				printf("%s force selected.\n\n", sam_chips[id_chip].name);
		} 
	}
	if (id_chip < 0) {
		id_chip = detect_chip(&sam_chips, &sam_series, &id_similar);
		if ((id_chip == -1) && (id_similar == -1)) {
			printf("ERROR: chip and series wasn't detected in following list:\n");
			list_chips(&sam_chips, NULL, 0);
			exit(EXIT_FAILURE);
		} else if (id_chip >=0) {
			if (argc <= 1)
				printf("%s detected.\n\n", sam_chips[id_chip].name);
		} else if (id_similar >=0) {
			printf("WARRING: No chip detected, use similar chip %s instead of.\n\n", \
				sam_chips[id_similar].name);
		}
	}

	// Process auxiliary options first
	while ((ret = getopt_long(argc, argv, opt_string, options, NULL)) >= 0) {
		switch(ret) {
			case 'F':
				force_dump = 1;
				break;
			case 's':
				similar_name = optarg;
				break;
			case 'a':
				info = INFO_LIST_MORE;
				break;
			case 'c':
			case 'm':
			case 'r':
			case 'D':
			case 'C':
			case 'h':
			case 'v':
				break;
			default:
				fprintf(stderr, "%s: wrong option. Use -h for help.\n", argv[0]);
				exit(EXIT_FAILURE);
		}
	}

	optind = 0;
	// Process main options
	while ((ret = getopt_long(argc, argv, opt_string, options, NULL)) >= 0) {
		switch(ret) {
			case 'c':
				list_chips(&sam_chips, similar_name, info);
				exit(EXIT_SUCCESS);
			case 'm':
				printf("%s\n", sam_chips[id_chip].name);
				list_modules(&sam_chips[id_chip], similar_name, info);
				exit(EXIT_SUCCESS);
			case 'r':
				ret = exist_module(&sam_chips[id_chip], optarg);
				if (ret >= 0) {
					printf("%s\n", sam_chips[id_chip].name);
					printf("  %s_%s\n", (*sam_chips[id_chip].ips)[ret].name, \
						(*sam_chips[id_chip].ips)[ret].version);
					list_registers(&(*sam_chips[id_chip].ips)[ret], similar_name, info);
				} else {
					printf("%s\n  module \"%s\" does not exist\n", \
						sam_chips[id_chip].name, optarg);
				}
				exit(EXIT_SUCCESS);
			case 'D':
				ret = exist_module(&sam_chips[id_chip], optarg);
				if (ret >= 0) {
					printf("%s\n", sam_chips[id_chip].name);
					printf("  %s_%s\n", (*sam_chips[id_chip].ips)[ret].name, \
						(*sam_chips[id_chip].ips)[ret].version);
					list_registers(&(*sam_chips[id_chip].ips)[ret], similar_name, \
						force_dump==0?INFO_DUMP_SAFE:INFO_DUMP_FORCE);
				} else {
					printf("%s\n  module \"%s\" does not exist\n", \
						sam_chips[id_chip].name, optarg);
				}
				exit(EXIT_SUCCESS);
			case 'C':
				compare_register(&sam_chips[id_chip], optarg);
				exit(EXIT_SUCCESS);
			case 'h':
				usage(argv[0]);
				exit(EXIT_SUCCESS);
			case 'v':
				fprintf(stderr, "%s - %s\n", project, VERSION);
				exit(EXIT_SUCCESS);
			case 'F':
			case 's':
			case 'a':
				exit_error = 1;
				break;
			default:
				fprintf(stderr, "%s: wrong option. Use -h for help.\n", argv[0]);
				exit(EXIT_FAILURE);
		}
	}

	if (exit_error) {
		fprintf(stderr, "%s: error parameter format. Use -h for help.\n", argv[0]);
		exit(EXIT_FAILURE);
	}

	if (argc < 2) {
		usage(argv[0]);
		return 0;
		//cmdline();
	}

	// Process register access
	ret = strlen(argv[1]);
	ip_name  = strtok(argv[1], "_");
	reg_name = strtok(NULL, "_");
	if ((ip_name == NULL) || (reg_name == NULL)) {
		for(i=0; i<ret; i++) {
			if (argv[1][i] == '\0')
				argv[1][i] = '_';
		}
		printf("%s:\n  incorrect register name format \"%s\"\n", \
			sam_chips[id_chip].name, argv[1]);
		return -1;
	}

	address = search_register(sam_chips[id_chip].ips, ip_name, reg_name);
	if (address == 0) {
		printf("%s:\n  register \"%s_%s\" does not exist\n", \
			sam_chips[id_chip].name, ip_name, reg_name);
		return -1;
	}
	if (argc == 3) {
		if (strcmp(argv[2], "b") == 0) {
			access = BYTE;
		} else if (strcmp(argv[2], "h") == 0) {
			access = HALF;
		} else if (strcmp(argv[2], "w") == 0) {
			access = WORD;
		} else {
			usage(argv[0]);
			return -1;
		}
	}
	if (argc == 4) {
		data = strtoul(argv[3], NULL, 16);
		access |= WR;
	} else
		access |= RD;

	memdev2(address, data, access, 1);

	return 0;
}

